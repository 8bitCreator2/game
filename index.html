<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stardust</title>
  <style>
    :root {
      --bg: #121212;
      --panel: #111111;
      --line: #2f2f2f;
      --text: #f4f4f4;
      --muted: #b8b8b8;
      --accent: #ffffff;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: radial-gradient(circle at center, #3a3a3a 0%, #232323 42%, var(--bg) 100%);
      color: var(--text);
      font-family: "Press Start 2P", "VT323", "IBM Plex Mono", monospace;
      padding: 1rem;
    }

    .app {
      width: min(980px, 97vw);
      border: 1px solid var(--line);
      background: var(--panel);
      padding: 1rem;
    }

    h1 {
      margin: 0 0 0.8rem;
      font-size: 1.05rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.07em;
    }

    .grid, .upgrades {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 0.6rem;
      margin-bottom: 0.7rem;
    }

    .card {
      border: 1px solid var(--line);
      background: #161616;
      padding: 0.65rem;
      box-shadow: inset 0 0 10px rgba(255, 241, 118, 0.06);
    }

    #rankCard,
    #u5Card {
      border-color: #a08d2e;
    }

    .label, .upgrade-title {
      color: var(--muted);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.25rem;
    }

    .value {
      font-size: 1.02rem;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
    }

    .muted {
      color: var(--muted);
      font-size: 0.8rem;
      line-height: 1.45;
      word-break: break-word;
      margin: 0.15rem 0;
    }

    .subtab {
      margin-top: 0.55rem;
      padding-top: 0.55rem;
      border-top: 1px dashed #4a4a4a;
    }

    button {
      margin-top: 0.45rem;
      width: 100%;
      border: 1px solid #4a4a4a;
      background: #121212;
      color: var(--accent);
      padding: 0.5rem;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 0.7rem;
      cursor: pointer;
    }

    button:hover:not(:disabled) {
      border-color: #fff9b0;
      color: #fff;
    }

    button:disabled {
      cursor: not-allowed;
      color: #8a8358;
      border-color: #303030;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: repeating-linear-gradient(to bottom, rgba(0, 0, 0, 0.11) 0, rgba(0, 0, 0, 0.11) 2px, transparent 2px, transparent 4px);
      opacity: 0.33;
    }
  </style>
</head>
<body>
  <main class="app">
    <h1>Stardust Incremental</h1>

    <section class="grid">
      <article class="card">
        <div class="label">Current Stardust</div>
        <div class="value" id="stardust">0</div>
      </article>

      <article class="card">
        <div class="label">Generation / second</div>
        <div class="value" id="gps">1</div>
      </article>

      <article class="card" id="rankCard">
        <div class="label">Stardust Rank</div>
        <div class="value" id="rank">0</div>
        <p class="muted" id="rankReq"></p>
        <button id="rankUp">Rank up</button>
      </article>

      <article class="card" id="tierCard" hidden>
        <div class="label">Stardust Tier</div>
        <div class="value" id="tier">0</div>
        <p class="muted" id="tierReq"></p>
        <button id="tierUp">Tier up</button>
      </article>

      <article class="card">
        <div class="label">Current Base + Current Boost</div>
        <div class="muted" id="currentStats"></div>
      </article>

      <article class="card">
        <div class="label">Rank Milestones</div>
        <div class="muted" id="milestones"></div>
      </article>

      <article class="card">
        <div class="label">What "Weighted" Means</div>
        <div class="muted" id="weightedHelp"></div>
      </article>
      <article class="card">
        <div class="label">Pacing Boost Details</div>
        <div class="muted" id="pacingHelp"></div>
      </article>
    </section>

    <section class="upgrades">
      <article class="card">
        <div class="upgrade-title">Upgrade 1 · Dust Scoop</div>
        <p class="muted">+1 base generation each level.</p>
        <p class="muted" id="u1"></p>
        <button id="buy1">Buy</button>

        <div class="subtab" id="sub1Card" hidden>
          <div class="upgrade-title">Subupgrade 1 · Dust Scoop Core</div>
          <p class="muted">For Upgrade 1: +1% to its effect per sub-level.</p>
          <p class="muted" id="sub1"></p>
          <button id="buySub1">Buy Subupgrade</button>
        </div>
      </article>

      <article class="card">
        <div class="upgrade-title">Upgrade 2 · Amplifier</div>
        <p class="muted">Increases generation by current % (diminishing stack).</p>
        <p class="muted" id="u2"></p>
        <button id="buy2">Buy</button>
      </article>

      <article class="card">
        <div class="upgrade-title">Upgrade 3 · Calibration</div>
        <p class="muted">Increases Upgrade 2 base by +8% each level.</p>
        <p class="muted" id="u3"></p>
        <button id="buy3">Buy</button>
      </article>

      <article class="card">
        <div class="upgrade-title">Upgrade 4 · Stabilizer</div>
        <p class="muted">+35% additive boost to Upgrade 2 base each level.</p>
        <p class="muted" id="u4"></p>
        <button id="buy4">Buy</button>
      </article>

      <article class="card" id="u5Card" hidden>
        <div class="upgrade-title">Upgrade 5 · Compression</div>
        <p class="muted">Reduces upgrade costs (except itself).</p>
        <p class="muted" id="u5"></p>
        <button id="buy5">Buy</button>
      </article>

    </section>
  </main>

  <script>
    const game = {
      stardust: 0,
      rank: 0,
      tier: 0,
      upgrades: [0, 0, 0, 0, 0],
      subUpgrades: [0],
      baseCosts: [9, 28, 72, 150, 950]
    };

    const format = (n, digits = 2) => {
      if (!Number.isFinite(n)) return '∞';
      const sign = n < 0 ? '-' : '';
      const value = Math.abs(n);
      if (value < 1000) {
        return sign + value.toLocaleString(undefined, { maximumFractionDigits: digits });
      }
      const suffixes = ['', 'K', 'M', 'B', 'T', 'Qa', 'Qi', 'Sx', 'Sp'];
      let tier = 0;
      let scaled = value;
      while (scaled >= 1000 && tier < suffixes.length - 1) {
        scaled /= 1000;
        tier += 1;
      }
      return `${sign}${scaled.toFixed(scaled >= 100 ? 0 : scaled >= 10 ? 1 : 2)}${suffixes[tier]}`;
    };

    const rankUnlocked = () => game.upgrades[3] >= 5;
    const tierUnlocked = () => game.rank >= 4;
    const tierRequirementRank = () => 4 + game.tier * 5;
    const upgrade5Unlocked = () => game.rank >= 1;
    const sub1Unlocked = () => game.rank >= 5;

    const rankRequirementU4Level = () => {
      if (game.rank <= 4) {
        return 5 + game.rank * 2;
      }
      return 13 + (game.rank - 4) * 3;
    };

    const rankPerRankBoost = () => (game.rank <= 2 ? 1.2 : 1.35);

    const rankGenerationMultiplier = () => {
      if (game.rank === 0) return 1;
      if (game.rank === 1) return 2;
      if (game.rank === 2) return 2.4;
      return 2.4 * Math.pow(1.35, game.rank - 2);
    };

    const stabilizerRankBoost = () => (game.rank >= 3 ? 1.1 : 1);

    const stabilizerBasePercent = () => {
      const lvl = game.upgrades[3];
      const preSoftcap = Math.min(lvl, 9) * 35;
      const postLevels = Math.max(0, lvl - 9);
      const postSoftcap = postLevels * 8;
      return preSoftcap + postSoftcap;
    };

    const stabilizerMultiplier = () => 1 + stabilizerBasePercent() / 100;

    const tierU3ToU1Boost = () => {
      if (game.tier < 1) return 1;
      return 1 + game.upgrades[2] * 0.015;
    };

    const sub1Multiplier = () => 1 + game.subUpgrades[0] * 0.01;

    const weightFalloff = () => (game.rank >= 2 ? 0.09 : 0.12);

    const pacingMaxMultiplier = () => (game.rank >= 6 ? 5 : 1.5);

    const pacingBoost = () => {
      const progression = game.upgrades[0] + game.upgrades[1] + game.upgrades[2] + game.upgrades[3];
      const rankPart = game.rank * 0.04;
      const tierPart = game.tier * 0.08;
      const capAdd = pacingMaxMultiplier() - 1;
      return 1 + Math.min(capAdd, progression * 0.01 + rankPart + tierPart);
    };

    const costReducer = () => {
      if (!upgrade5Unlocked()) return 1;
      const level = game.upgrades[4];
      const reduceBy = Math.min(0.45, 1 - Math.pow(0.96, level));
      return 1 - reduceBy;
    };

    const upgradeCost = (index) => {
      const growth = [1.34, 1.75, 1.95, 2.08, 2.62][index];
      const base = game.baseCosts[index] * Math.pow(growth, game.upgrades[index]);
      if (index === 4) return Math.floor(base);
      return Math.floor(base * costReducer());
    };

    const sub1Requirement = () => (game.subUpgrades[0] + 1) * 5;
    const sub1Cost = () => {
      const ratio = Math.max(1, Math.floor(game.upgrades[0] / 5));
      return Math.floor(140 * Math.pow(1.58, game.subUpgrades[0]) / ratio);
    };

    const upgrade2BasePercentRaw = () => {
      const base = 20;
      const calibrationBoost = 1 + game.upgrades[2] * 0.08;
      const stabilizerBoost = stabilizerMultiplier() * stabilizerRankBoost();
      return base * calibrationBoost * stabilizerBoost;
    };

    const dampenPercent = (rawPercent) => {
      if (rawPercent <= 70) return rawPercent;
      if (rawPercent <= 220) return 70 + Math.pow(rawPercent - 70, 0.5) * 5;
      return 70 + Math.pow(150, 0.5) * 5 + Math.log10(rawPercent - 219) * 8;
    };

    const weightedU2Levels = (levels) => {
      let total = 0;
      for (let i = 0; i < levels; i += 1) {
        total += 1 / (1 + i * weightFalloff());
      }
      return total;
    };

    const currentBaseGeneration = () => {
      const u1Base = (1 + game.upgrades[0]) * sub1Multiplier();
      return u1Base * rankGenerationMultiplier() * tierU3ToU1Boost() * pacingBoost();
    };

    const currentUpgrade2Multiplier = () => {
      const u2PercentEach = dampenPercent(upgrade2BasePercentRaw());
      const u2LevelsWeighted = weightedU2Levels(game.upgrades[1]);
      return Math.pow(1 + u2PercentEach / 100, u2LevelsWeighted);
    };

    const generationPerSecond = () => currentBaseGeneration() * currentUpgrade2Multiplier();

    function buyUpgrade(index) {
      const cardLocked = index === 4 && !upgrade5Unlocked();
      if (cardLocked) return;
      const cost = upgradeCost(index);
      if (game.stardust < cost) return;
      game.stardust -= cost;
      game.upgrades[index] += 1;
      render();
    }

    function buySub1() {
      if (!sub1Unlocked()) return;
      if (game.upgrades[0] < sub1Requirement()) return;
      const cost = sub1Cost();
      if (game.stardust < cost) return;
      game.stardust -= cost;
      game.subUpgrades[0] += 1;
      render();
    }

    function rankUp() {
      if (!rankUnlocked()) return;
      if (game.upgrades[3] < rankRequirementU4Level()) return;
      game.rank += 1;
      game.stardust = 0;
      game.upgrades = [0, 0, 0, 0, 0];
      render();
    }

    function tierUp() {
      if (!tierUnlocked()) return;
      if (game.rank < tierRequirementRank()) return;
      game.tier += 1;
      game.rank = 0;
      game.stardust = 0;
      game.upgrades = [0, 0, 0, 0, 0];
      render();
    }

    function render() {
      const gps = generationPerSecond();
      const baseGen = currentBaseGeneration();
      const raw = upgrade2BasePercentRaw();
      const eff = dampenPercent(raw);
      const weighted = weightedU2Levels(game.upgrades[1]);
      const u2CurrentMultiplier = currentUpgrade2Multiplier();

      document.getElementById('stardust').textContent = format(game.stardust);
      document.getElementById('gps').textContent = format(gps, 3);
      document.getElementById('rank').textContent = game.rank;
      document.getElementById('tier').textContent = game.tier;

      const rankButton = document.getElementById('rankUp');
      if (!rankUnlocked()) {
        document.getElementById('rankReq').textContent = 'Unlock at Upgrade 4 level 5.';
        rankButton.disabled = true;
      } else {
        document.getElementById('rankReq').textContent = `Requirement: Upgrade 4 level ${rankRequirementU4Level()} (+2 until rank 4, then +3). Per-rank gen boost x${format(rankPerRankBoost(), 2)} (higher after Rank 2). Rank 3 bonus: U4 x1.10.`;
        rankButton.disabled = game.upgrades[3] < rankRequirementU4Level();
      }

      const tierButton = document.getElementById('tierUp');
      document.getElementById('tierCard').hidden = !tierUnlocked();
      if (!tierUnlocked()) {
        document.getElementById('tierReq').textContent = 'Locked: unlocks at Rank 4.';
        tierButton.disabled = true;
      } else {
        document.getElementById('tierReq').textContent = `Requirement: Rank ${tierRequirementRank()} (+5 each tier). Tier resets rank, stardust, and upgrades.`;
        tierButton.disabled = game.rank < tierRequirementRank();
      }

      document.getElementById('u5Card').hidden = !upgrade5Unlocked();
      document.getElementById('sub1Card').hidden = !sub1Unlocked();

      const u1RawBase = 1 + game.upgrades[0];
      const u1SubBoost = sub1Multiplier();
      const rankBoost = rankGenerationMultiplier();
      const tierBoost = tierU3ToU1Boost();
      const paceBoost = pacingBoost();
      const stabilizerBase = stabilizerMultiplier();
      const stabilizerRank = stabilizerRankBoost();

      document.getElementById('currentStats').innerHTML = [
        '<b>Bases</b>',
        `U1 raw base: <b>${format(u1RawBase, 2)}/s</b>`,
        `U2 raw base effect: <b>${format(raw, 2)}%</b>`,
        '<b>Boosts</b>',
        `Subupgrade 1 (U1): <b>x${format(u1SubBoost, 3)}</b>`,
        `Rank generation: <b>x${format(rankBoost, 3)}</b>`,
        `Rank per-rank boost: <b>x${format(rankPerRankBoost(), 2)}</b>`,
        `Rank 3 bonus (U4): <b>x${format(stabilizerRank, 3)}</b>`,
        `Tier synergy: <b>x${format(tierBoost, 3)}</b>`,
        `Pacing boost: <b>x${format(paceBoost, 3)}</b>`,
        `U4 stabilizer base: <b>x${format(stabilizerBase, 3)}</b>`,
        `U2 total multiplier: <b>x${format(u2CurrentMultiplier, 3)}</b>`,
        `Total GPS: <b>${format(gps, 3)}/s</b>`
      ].join('<br>');

      const milestones = [
        `${game.rank >= 1 ? '✓' : '·'} Rank 1: Unlock Upgrade 5 + generation x2`,
        `${game.rank >= 2 ? '✓' : '·'} Rank 2: Better Upgrade 2 weighting + stronger rank scaling`,
        `${game.rank >= 3 ? '✓' : '·'} Rank 3: Upgrade 4 effect x1.10`,
        `${game.rank >= 4 ? '✓' : '·'} Rank 4: Unlock Tier system`,
        `${game.rank >= 5 ? '✓' : '·'} Rank 5: Unlock Subupgrade 1 (for Upgrade 1)`,
        `${game.tier >= 1 ? '✓' : '·'} Tier 1: Upgrade 3 boosts Upgrade 1 a little`
      ];
      document.getElementById('milestones').innerHTML = milestones.join('<br>');

      const weightedNow = weightedU2Levels(game.upgrades[1]);
      const nextWeighted = weightedU2Levels(game.upgrades[1] + 1);
      document.getElementById('weightedHelp').innerHTML = [
        'Weighted = each Upgrade 2 level gives a little less than the one before.',
        `Current: <b>${game.upgrades[1]} levels => ${format(weightedNow, 2)} weighted</b>`,
        `Next level adds: <b>+${format(nextWeighted - weightedNow, 3)} weighted</b>`,
        `Weight falloff: <b>${weightFalloff()}</b> (${game.rank >= 2 ? 'improved by Rank 2' : 'base'})`,
        `Pacing boost: <b>x${format(pacingBoost(), 3)}</b> (scales with progress, rank, tier)`
      ].join('<br>');

      const pacingProgress = game.upgrades[0] + game.upgrades[1] + game.upgrades[2] + game.upgrades[3];
      const paceCapAdd = pacingMaxMultiplier() - 1;
      const pacingFromProgress = Math.min(paceCapAdd, pacingProgress * 0.01);
      const pacingFromRank = Math.min(Math.max(0, paceCapAdd - pacingFromProgress), game.rank * 0.04);
      const pacingFromTier = Math.max(0, Math.min(Math.max(0, paceCapAdd - pacingFromProgress - pacingFromRank), game.tier * 0.08));
      document.getElementById('pacingHelp').innerHTML = [
        `Current pacing boost: <b>x${format(pacingBoost(), 3)}</b>`,
        `From upgrades: <b>+${format(pacingFromProgress * 100, 2)}%</b>`,
        `From rank: <b>+${format(pacingFromRank * 100, 2)}%</b>`,
        `From tier: <b>+${format(pacingFromTier * 100, 2)}%</b>`,
        `Cap: x${format(pacingMaxMultiplier(), 2)} total pacing boost ${game.rank >= 6 ? '(Rank 6 reached)' : '(Reach Rank 6 for x5 cap)'}`
      ].join('<br>');

      const u1CurrentBase = u1RawBase * sub1Multiplier();
      const labels = [
        `lvl ${game.upgrades[0]} · raw base ${format(u1RawBase, 2)}/s · current ${format(u1CurrentBase, 2)}/s · next ${upgradeCost(0)} stardust`,
        `lvl ${game.upgrades[1]} · raw ${format(raw)}% · current ${format(eff)}% · boost x${format(u2CurrentMultiplier, 3)} · next ${upgradeCost(1)}`,
        `lvl ${game.upgrades[2]} · raw +${format(game.upgrades[2] * 8)}% to u2 · current x${format(1 + game.upgrades[2] * 0.08, 3)} · next ${upgradeCost(2)} stardust`,
        `lvl ${game.upgrades[3]} · raw +${format(stabilizerBasePercent(), 1)}% to u2 (softcap after 9) · current x${format(stabilizerMultiplier() * stabilizerRankBoost(), 3)} · next ${upgradeCost(3)} stardust`,
        `lvl ${game.upgrades[4]} · current cost reduction ${format((1 - costReducer()) * 100)}% · next ${upgradeCost(4)} stardust`
      ];

      ['u1', 'u2', 'u3', 'u4', 'u5'].forEach((id, i) => {
        const labelEl = document.getElementById(id);
        if (!labelEl) return;
        labelEl.textContent = labels[i];
      });

      if (sub1Unlocked()) {
        document.getElementById('sub1').textContent = `lvl ${game.subUpgrades[0]} · current boost +${format(game.subUpgrades[0])}% to Upgrade 1 · requires U1 lvl ${sub1Requirement()} · next ${sub1Cost()} stardust`;
      }

      [1, 2, 3, 4, 5].forEach((n, i) => {
        const btn = document.getElementById(`buy${n}`);
        if (!btn) return;
        if (i === 4 && !upgrade5Unlocked()) {
          btn.disabled = true;
          return;
        }
        btn.disabled = game.stardust < upgradeCost(i);
      });

      const sub1Btn = document.getElementById('buySub1');
      if (sub1Btn) {
        sub1Btn.disabled = !sub1Unlocked() || game.stardust < sub1Cost() || game.upgrades[0] < sub1Requirement();
      }
    }

    document.getElementById('buy1').addEventListener('click', () => buyUpgrade(0));
    document.getElementById('buy2').addEventListener('click', () => buyUpgrade(1));
    document.getElementById('buy3').addEventListener('click', () => buyUpgrade(2));
    document.getElementById('buy4').addEventListener('click', () => buyUpgrade(3));
    document.getElementById('buy5').addEventListener('click', () => buyUpgrade(4));
    document.getElementById('buySub1').addEventListener('click', buySub1);
    document.getElementById('rankUp').addEventListener('click', rankUp);
    document.getElementById('tierUp').addEventListener('click', tierUp);

    setInterval(() => {
      game.stardust += generationPerSecond() / 20;
      render();
    }, 50);

    render();
  </script>
</body>
</html>
