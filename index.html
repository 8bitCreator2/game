<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stardust</title>
  <style>
    :root {
      --bg: #121212;
      --panel: #111111;
      --line: #2f2f2f;
      --text: #f4f4f4;
      --muted: #b8b8b8;
      --accent: #ffffff;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: radial-gradient(circle at center, #3a3a3a 0%, #232323 42%, var(--bg) 100%);
      color: var(--text);
      font-family: "Press Start 2P", "VT323", "IBM Plex Mono", monospace;
      padding: 1rem;
    }

    .app {
      width: min(980px, 97vw);
      border: 1px solid var(--line);
      background: var(--panel);
      padding: 1rem;
    }

    h1 {
      margin: 0 0 0.8rem;
      font-size: 1.05rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.07em;
    }

    .grid, .upgrades {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 0.6rem;
      margin-bottom: 0.7rem;
    }

    .card {
      border: 1px solid var(--line);
      background: #161616;
      padding: 0.65rem;
      box-shadow: inset 0 0 10px rgba(255, 241, 118, 0.06);
    }

    #rankCard,
    #u5Card {
      border-color: #a08d2e;
    }

    .label, .upgrade-title {
      color: var(--muted);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.25rem;
    }

    .value {
      font-size: 1.02rem;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
    }

    .muted {
      color: var(--muted);
      font-size: 0.8rem;
      line-height: 1.45;
      word-break: break-word;
      margin: 0.15rem 0;
    }

    .subtab {
      margin-top: 0.55rem;
      padding-top: 0.55rem;
      border-top: 1px dashed #4a4a4a;
    }

    button {
      margin-top: 0.45rem;
      width: 100%;
      border: 1px solid #4a4a4a;
      background: #121212;
      color: var(--accent);
      padding: 0.5rem;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 0.7rem;
      cursor: pointer;
    }

    button:hover:not(:disabled) {
      border-color: #fff9b0;
      color: #fff;
    }

    button:disabled {
      cursor: not-allowed;
      color: #8a8358;
      border-color: #303030;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: repeating-linear-gradient(to bottom, rgba(0, 0, 0, 0.11) 0, rgba(0, 0, 0, 0.11) 2px, transparent 2px, transparent 4px);
      opacity: 0.33;
    }
  </style>
</head>
<body>
  <main class="app">
    <h1>Stardust Incremental</h1>

    <section class="grid">
      <article class="card">
        <div class="label">Current Stardust</div>
        <div class="value" id="stardust">0</div>
      </article>

      <article class="card">
        <div class="label">Generation / second</div>
        <div class="value" id="gps">1</div>
      </article>

      <article class="card" id="rankCard">
        <div class="label">Stardust Rank</div>
        <div class="value" id="rank">0</div>
        <p class="muted" id="rankReq"></p>
        <button id="rankUp">Rank up</button>
      </article>

      <article class="card" id="tierCard" hidden>
        <div class="label">Stardust Tier</div>
        <div class="value" id="tier">0</div>
        <p class="muted" id="tierReq"></p>
        <button id="tierUp">Tier up</button>
      </article>

      <article class="card">
        <div class="label">Current Base + Current Boost</div>
        <div class="muted" id="currentStats"></div>
      </article>

      <article class="card">
        <div class="label">Save</div>
        <div class="muted" id="saveStatus">No save yet.</div>
        <button id="saveNow">Save Now</button>
        <button id="hardReset">Hard Reset</button>
      </article>

      <article class="card">
        <div class="label">Rank Milestones</div>
        <div class="muted" id="milestones"></div>
      </article>

      <article class="card">
        <div class="label">What "Weighted" Means</div>
        <div class="muted" id="weightedHelp"></div>
      </article>
      <article class="card">
        <div class="label">Pacing Boost Details</div>
        <div class="muted" id="pacingHelp"></div>
      </article>
      <article class="card">
        <div class="label">Quality of Life</div>
        <div class="muted" id="qolInfo"></div>
      </article>
    </section>

    <section class="upgrades">
      <article class="card">
        <div class="upgrade-title">Upgrade 1 · Dust Scoop</div>
        <p class="muted">+1 base generation each level.</p>
        <p class="muted" id="u1"></p>
        <button id="buy1">Buy</button>

        <div class="subtab" id="sub1Card" hidden>
          <div class="upgrade-title">Subupgrade 1 · Dust Scoop Core</div>
          <p class="muted">For Upgrade 1: +1% to its effect per sub-level.</p>
          <p class="muted" id="sub1"></p>
          <button id="buySub1">Buy Subupgrade</button>
        </div>
      </article>

      <article class="card">
        <div class="upgrade-title">Upgrade 2 · Amplifier</div>
        <p class="muted">Increases generation by current % (diminishing stack).</p>
        <p class="muted" id="u2"></p>
        <button id="buy2">Buy</button>

        <div class="subtab" id="sub2Card" hidden>
          <div class="upgrade-title">Subupgrade 2 · Amplifier Core</div>
          <p class="muted">Reduces weighted falloff by -0.01 each level.</p>
          <p class="muted" id="sub2"></p>
          <button id="buySub2">Buy Subupgrade</button>
        </div>
      </article>

      <article class="card">
        <div class="upgrade-title">Upgrade 3 · Calibration</div>
        <p class="muted">Increases Upgrade 2 base by +8% each level.</p>
        <p class="muted" id="u3"></p>
        <button id="buy3">Buy</button>

        <div class="subtab" id="sub3Card" hidden>
          <div class="upgrade-title">Subupgrade 3 · Calibration Matrix</div>
          <p class="muted">Boosts Upgrade 3 effectiveness by +2% each level.</p>
          <p class="muted" id="sub3"></p>
          <button id="buySub3">Buy Subupgrade</button>
        </div>
      </article>

      <article class="card">
        <div class="upgrade-title">Upgrade 4 · Stabilizer</div>
        <p class="muted">+35% additive boost to Upgrade 2 base each level.</p>
        <p class="muted" id="u4"></p>
        <button id="buy4">Buy</button>
      </article>

      <article class="card" id="u5Card" hidden>
        <div class="upgrade-title">Upgrade 5 · Compression</div>
        <p class="muted">Reduces upgrade costs (except itself).</p>
        <p class="muted" id="u5"></p>
        <button id="buy5">Buy</button>
      </article>

    </section>
  </main>

  <script>
    const game = {
      stardust: 0,
      rank: 0,
      tier: 0,
      upgrades: [0, 0, 0, 0, 0],
      subUpgrades: [0, 0, 0],
      baseCosts: [9, 28, 72, 150, 950],
      tierUnlocked: false
    };

    const SAVE_KEY = 'stardust_incremental_save_v1';
    let lastSavedAt = null;

    const defaultState = () => ({
      stardust: 0,
      rank: 0,
      tier: 0,
      upgrades: [0, 0, 0, 0, 0],
      subUpgrades: [0, 0, 0],
      tierUnlocked: false
    });

    function applyState(state) {
      const safe = defaultState();
      game.stardust = Number.isFinite(state.stardust) ? Math.max(0, state.stardust) : safe.stardust;
      game.rank = Number.isFinite(state.rank) ? Math.max(0, Math.floor(state.rank)) : safe.rank;
      game.tier = Number.isFinite(state.tier) ? Math.max(0, Math.floor(state.tier)) : safe.tier;
      game.upgrades = Array.isArray(state.upgrades) ? safe.upgrades.map((_, i) => {
        const v = state.upgrades[i];
        return Number.isFinite(v) ? Math.max(0, Math.floor(v)) : 0;
      }) : safe.upgrades;
      game.subUpgrades = Array.isArray(state.subUpgrades) ? safe.subUpgrades.map((_, i) => {
        const v = state.subUpgrades[i];
        return Number.isFinite(v) ? Math.max(0, Math.floor(v)) : 0;
      }) : safe.subUpgrades;
      game.tierUnlocked = state.tierUnlocked === true || game.tier >= 1 || game.rank >= 4;
    }

    function saveGame() {
      const payload = {
        stardust: game.stardust,
        rank: game.rank,
        tier: game.tier,
        upgrades: game.upgrades,
        subUpgrades: game.subUpgrades,
        tierUnlocked: game.tierUnlocked,
        savedAt: Date.now()
      };
      localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
      lastSavedAt = payload.savedAt;
    }

    function loadGame() {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return false;
      try {
        const parsed = JSON.parse(raw);
        applyState(parsed);
        lastSavedAt = Number.isFinite(parsed.savedAt) ? parsed.savedAt : null;
        return true;
      } catch {
        return false;
      }
    }

    function hardResetGame() {
      localStorage.removeItem(SAVE_KEY);
      applyState(defaultState());
      lastSavedAt = null;
      render();
    }

    const format = (n, digits = 2) => {
      if (!Number.isFinite(n)) return '∞';
      const sign = n < 0 ? '-' : '';
      const value = Math.abs(n);
      if (value < 1000) {
        return sign + value.toLocaleString(undefined, { maximumFractionDigits: digits });
      }
      const suffixes = ['', 'K', 'M', 'B', 'T', 'Qa', 'Qi', 'Sx', 'Sp'];
      let tier = 0;
      let scaled = value;
      while (scaled >= 1000 && tier < suffixes.length - 1) {
        scaled /= 1000;
        tier += 1;
      }
      return `${sign}${scaled.toFixed(scaled >= 100 ? 0 : scaled >= 10 ? 1 : 2)}${suffixes[tier]}`;
    };

    const rankUnlocked = () => game.upgrades[3] >= 5;
    const tierUnlocked = () => game.tierUnlocked || game.rank >= 4;
    const tierRequirementRank = () => 4 + game.tier * 5;
    const upgrade5Unlocked = () => game.rank >= 1;
    const sub1Unlocked = () => game.rank >= 5;
    const sub2Unlocked = () => game.tier >= 1;
    const sub3Unlocked = () => game.rank >= 9;

    const rankRequirementU4Level = () => {
      if (game.rank <= 4) {
        return 5 + game.rank * 2;
      }
      return 13 + (game.rank - 4) * 3;
    };

    const rankPerRankBoost = () => 1.2;

    const rankGenerationMultiplier = () => {
      if (game.rank === 0) return 1;
      return 2 * Math.pow(rankPerRankBoost(), Math.max(0, game.rank - 1));
    };

    const stabilizerRankBoost = () => 1;

    const stabilizerBasePercent = () => {
      const lvl = game.upgrades[3];
      const preSoftcap = Math.min(lvl, 9) * 35;
      const postLevels = Math.max(0, lvl - 9);
      const postSoftcap = postLevels * 8;
      return preSoftcap + postSoftcap;
    };

    const stabilizerMultiplier = () => 1 + stabilizerBasePercent() / 100;

    const tierU3ToU1Boost = () => 1;

    const sub1Multiplier = () => 1 + game.subUpgrades[0] * 0.01;

    const weightFalloff = () => {
      const base = game.rank >= 3 ? 0.07 : 0.12;
      const sub2Reduce = game.subUpgrades[1] * 0.01;
      return Math.max(0.02, base - sub2Reduce);
    };

    const pacingMaxMultiplier = () => (game.tier >= 2 ? 25 : 1.5);

    const pacingBoost = () => {
      const progression = game.upgrades[0] + game.upgrades[1] + game.upgrades[2] + game.upgrades[3];
      const rankPart = game.rank * 0.04;
      const tierPart = game.tier * 0.08;
      const capAdd = pacingMaxMultiplier() - 1;
      return 1 + Math.min(capAdd, progression * 0.01 + rankPart + tierPart);
    };

    const costReducer = () => {
      if (!upgrade5Unlocked()) return 1;
      const level = Math.min(5, game.upgrades[4]);
      const reduceBy = Math.min(0.45, 1 - Math.pow(0.96, level));
      return 1 - reduceBy;
    };

    const post25CostScale = (level) => {
      if (level < 25) return 1;
      const extra = level - 24;
      return Math.pow(1.09, extra) * (1 + extra * 0.035);
    };

    const upgradeCost = (index) => {
      const growth = [1.34, 1.75, 1.95, 2.08, 2.62][index];
      const level = game.upgrades[index];
      const base = game.baseCosts[index] * Math.pow(growth, level);
      const scaled = base * post25CostScale(level);
      if (index === 4) return Math.floor(scaled);
      return Math.floor(scaled * costReducer());
    };

    const sub1Requirement = () => (game.subUpgrades[0] + 1) * 5;
    const sub1Cost = () => {
      const ratio = Math.max(1, Math.floor(game.upgrades[0] / 5));
      return Math.floor(140 * Math.pow(1.58, game.subUpgrades[0]) / ratio);
    };

    const sub2Requirement = () => (game.subUpgrades[1] + 1) * 5;
    const sub2Cost = () => {
      const ratio = Math.max(1, Math.floor(game.upgrades[1] / 5));
      return Math.floor(180 * Math.pow(1.62, game.subUpgrades[1]) / ratio);
    };

    const sub3Requirement = () => (game.subUpgrades[2] + 1) * 6;
    const sub3Cost = () => {
      const ratio = Math.max(1, Math.floor(game.upgrades[2] / 6));
      return Math.floor(240 * Math.pow(1.68, game.subUpgrades[2]) / ratio);
    };

    const upgrade2BasePercentRaw = () => {
      const base = 20;
      const calibrationBoost = 1 + game.upgrades[2] * 0.08 * (1 + game.subUpgrades[2] * 0.02);
      const stabilizerBoost = stabilizerMultiplier() * stabilizerRankBoost();
      return base * calibrationBoost * stabilizerBoost;
    };

    const dampenPercent = (rawPercent) => {
      if (rawPercent <= 70) return rawPercent;
      if (rawPercent <= 220) return 70 + Math.pow(rawPercent - 70, 0.5) * 5;
      return 70 + Math.pow(150, 0.5) * 5 + Math.log10(rawPercent - 219) * 8;
    };

    const weightedU2Levels = (levels) => {
      let total = 0;
      for (let i = 0; i < levels; i += 1) {
        total += 1 / (1 + i * weightFalloff());
      }
      return total;
    };

    const currentBaseGeneration = () => {
      const u1Base = (1 + game.upgrades[0]) * sub1Multiplier();
      return u1Base * rankGenerationMultiplier() * tierU3ToU1Boost() * pacingBoost();
    };

    const currentUpgrade2Multiplier = () => {
      const u2PercentEach = dampenPercent(upgrade2BasePercentRaw());
      const u2LevelsWeighted = weightedU2Levels(game.upgrades[1]);
      return Math.pow(1 + u2PercentEach / 100, u2LevelsWeighted);
    };

    const generationPerSecond = () => currentBaseGeneration() * currentUpgrade2Multiplier();

    function buyUpgrade(index) {
      const cardLocked = index === 4 && !upgrade5Unlocked();
      if (cardLocked) return;
      if (index === 4 && game.upgrades[4] >= 5) return;
      const cost = upgradeCost(index);
      if (game.stardust < cost) return;
      game.stardust -= cost;
      game.upgrades[index] += 1;
      render();
    }

    function buySub1() {
      if (!sub1Unlocked()) return;
      if (game.upgrades[0] < sub1Requirement()) return;
      const cost = sub1Cost();
      if (game.stardust < cost) return;
      game.stardust -= cost;
      game.subUpgrades[0] += 1;
      render();
    }

    function buySub2() {
      if (!sub2Unlocked()) return;
      if (game.upgrades[1] < sub2Requirement()) return;
      const cost = sub2Cost();
      if (game.stardust < cost) return;
      game.stardust -= cost;
      game.subUpgrades[1] += 1;
      render();
    }

    function buySub3() {
      if (!sub3Unlocked()) return;
      if (game.upgrades[2] < sub3Requirement()) return;
      const cost = sub3Cost();
      if (game.stardust < cost) return;
      game.stardust -= cost;
      game.subUpgrades[2] += 1;
      render();
    }

    function rankUp() {
      if (!rankUnlocked()) return;
      if (game.upgrades[3] < rankRequirementU4Level()) return;
      game.rank += 1;
      game.stardust = 0;
      game.upgrades = [0, 0, 0, 0, 0];
      render();
    }

    function tierUp() {
      if (!tierUnlocked()) return;
      if (game.rank < tierRequirementRank()) return;
      game.tier += 1;
      game.rank = 0;
      game.stardust = 0;
      game.upgrades = [0, 0, 0, 0, 0];
      render();
    }

    function render() {
      if (game.rank >= 4 && !game.tierUnlocked) game.tierUnlocked = true;

      const gps = generationPerSecond();
      const baseGen = currentBaseGeneration();
      const raw = upgrade2BasePercentRaw();
      const eff = dampenPercent(raw);
      const weighted = weightedU2Levels(game.upgrades[1]);
      const u2CurrentMultiplier = currentUpgrade2Multiplier();

      document.getElementById('stardust').textContent = format(game.stardust);
      document.getElementById('gps').textContent = format(gps, 3);
      document.getElementById('rank').textContent = game.rank;
      document.getElementById('tier').textContent = game.tier;

      const rankButton = document.getElementById('rankUp');
      if (!rankUnlocked()) {
        document.getElementById('rankReq').textContent = 'Unlock at Upgrade 4 level 5.';
        rankButton.disabled = true;
      } else {
        document.getElementById('rankReq').textContent = `Requirement: Upgrade 4 level ${rankRequirementU4Level()} (+2 until rank 4, then +3). Per-rank gen boost x${format(rankPerRankBoost(), 2)}. Rank 3 bonus: much better weighted scaling.`;
        rankButton.disabled = game.upgrades[3] < rankRequirementU4Level();
      }

      const tierButton = document.getElementById('tierUp');
      document.getElementById('tierCard').hidden = !tierUnlocked();
      if (!tierUnlocked()) {
        document.getElementById('tierReq').textContent = 'Locked: unlocks at Rank 4.';
        tierButton.disabled = true;
      } else {
        document.getElementById('tierReq').textContent = `Requirement: Rank ${tierRequirementRank()} (+5 each tier). Tier resets rank, stardust, and upgrades.`;
        tierButton.disabled = game.rank < tierRequirementRank();
      }

      document.getElementById('u5Card').hidden = !upgrade5Unlocked();
      document.getElementById('sub1Card').hidden = !sub1Unlocked();
      document.getElementById('sub2Card').hidden = !sub2Unlocked();
      document.getElementById('sub3Card').hidden = !sub3Unlocked();

      const u1RawBase = 1 + game.upgrades[0];
      const u1SubBoost = sub1Multiplier();
      const rankBoost = rankGenerationMultiplier();
      const tierBoost = tierU3ToU1Boost();
      const paceBoost = pacingBoost();
      const stabilizerBase = stabilizerMultiplier();
      
      document.getElementById('currentStats').innerHTML = [
        '<b>Bases</b>',
        `U1 raw base: <b>${format(u1RawBase, 2)}/s</b>`,
        `U2 raw base effect: <b>${format(raw, 2)}%</b>`,
        '<b>Boosts</b>',
        `Subupgrade 1 (U1): <b>x${format(u1SubBoost, 3)}</b>`,
        `Rank generation: <b>x${format(rankBoost, 3)}</b>`,
        `Rank per-rank boost: <b>x${format(rankPerRankBoost(), 2)}</b>`,
        `Rank 3 bonus (weighted): <b>falloff ${format(weightFalloff(), 2)}</b>`,
        `Tier synergy: <b>x${format(tierBoost, 3)}</b>`,
        `Subupgrade 2 falloff cut: <b>-${format(game.subUpgrades[1] * 0.01, 2)}</b>`,
        `Subupgrade 3 calibration boost: <b>x${format(1 + game.subUpgrades[2] * 0.02, 3)}</b>`,
        `Pacing boost: <b>x${format(paceBoost, 3)}</b>`,
        `U4 stabilizer base: <b>x${format(stabilizerBase, 3)}</b>`,
        `U2 total multiplier: <b>x${format(u2CurrentMultiplier, 3)}</b>`,
        `Total GPS: <b>${format(gps, 3)}/s</b>`
      ].join('<br>');

      const saveLabel = document.getElementById('saveStatus');
      saveLabel.textContent = lastSavedAt
        ? `Last save: ${new Date(lastSavedAt).toLocaleTimeString()}`
        : 'No save yet.';

      const milestones = [
        `${game.rank >= 1 ? '✓' : '·'} Rank 1: Unlock Upgrade 5 + generation x2`,
        `${game.rank >= 2 ? '✓' : '·'} Rank 2: No special reward`,
        `${game.rank >= 3 ? '✓' : '·'} Rank 3: Better weighted scaling`,
        `${game.tierUnlocked ? '✓' : '·'} Rank 4: Unlock Tier system (permanent unlock)`,
        `${game.rank >= 5 ? '✓' : '·'} Rank 5: Unlock Subupgrade 1 (for Upgrade 1)`,
        `${game.tier >= 1 ? '✓' : '·'} Tier 1: Unlock Subupgrade 2 (Amplifier falloff -0.01)`,
        `${game.tier >= 2 ? '✓' : '·'} Tier 2: Pacing cap becomes x25`,
        `${game.rank >= 9 ? '✓' : '·'} Rank 9: Unlock Subupgrade 3`
      ];
      document.getElementById('milestones').innerHTML = milestones.join('<br>');

      const weightedNow = weightedU2Levels(game.upgrades[1]);
      const nextWeighted = weightedU2Levels(game.upgrades[1] + 1);
      document.getElementById('weightedHelp').innerHTML = [
        'Weighted = each Upgrade 2 level gives a little less than the one before.',
        `Current: <b>${game.upgrades[1]} levels => ${format(weightedNow, 2)} weighted</b>`,
        `Next level adds: <b>+${format(nextWeighted - weightedNow, 3)} weighted</b>`,
        `Weight falloff: <b>${weightFalloff()}</b> (${game.rank >= 3 ? 'improved by Rank 3 + Sub2' : 'base'})`,
        `Pacing boost: <b>x${format(pacingBoost(), 3)}</b> (scales with progress, rank, tier)`
      ].join('<br>');

      const pacingProgress = game.upgrades[0] + game.upgrades[1] + game.upgrades[2] + game.upgrades[3];
      const paceCapAdd = pacingMaxMultiplier() - 1;
      const pacingFromProgress = Math.min(paceCapAdd, pacingProgress * 0.01);
      const pacingFromRank = Math.min(Math.max(0, paceCapAdd - pacingFromProgress), game.rank * 0.04);
      const pacingFromTier = Math.max(0, Math.min(Math.max(0, paceCapAdd - pacingFromProgress - pacingFromRank), game.tier * 0.08));
      document.getElementById('pacingHelp').innerHTML = [
        `Current pacing boost: <b>x${format(pacingBoost(), 3)}</b>`,
        `From upgrades: <b>+${format(pacingFromProgress * 100, 2)}%</b>`,
        `From rank: <b>+${format(pacingFromRank * 100, 2)}%</b>`,
        `From tier: <b>+${format(pacingFromTier * 100, 2)}%</b>`,
        `Cap: x${format(pacingMaxMultiplier(), 2)} total pacing boost ${game.tier >= 2 ? '(Tier 2 active)' : '(Tier 2 unlocks x25 cap)'}`
      ].join('<br>');

      const u1CurrentBase = u1RawBase * sub1Multiplier();
      const labels = [
        `lvl ${game.upgrades[0]} · raw base ${format(u1RawBase, 2)}/s · current ${format(u1CurrentBase, 2)}/s · next ${upgradeCost(0)} stardust${game.upgrades[0] >= 25 ? ' · post-25 scaling' : ''}`,
        `lvl ${game.upgrades[1]} · raw ${format(raw)}% · current ${format(eff)}% · boost x${format(u2CurrentMultiplier, 3)} · next ${upgradeCost(1)}${game.upgrades[1] >= 25 ? ' · post-25 scaling' : ''}`,
        `lvl ${game.upgrades[2]} · raw +${format(game.upgrades[2] * 8)}% to u2 · current x${format(1 + game.upgrades[2] * 0.08 * (1 + game.subUpgrades[2] * 0.02), 3)} · next ${upgradeCost(2)} stardust${game.upgrades[2] >= 25 ? ' · post-25 scaling' : ''}`,
        `lvl ${game.upgrades[3]} · raw +${format(stabilizerBasePercent(), 1)}% to u2 (softcap after 9) · current x${format(stabilizerMultiplier() * stabilizerRankBoost(), 3)} · next ${upgradeCost(3)} stardust${game.upgrades[3] >= 25 ? ' · post-25 scaling' : ''}`,
        `lvl ${game.upgrades[4]} / 5 · current cost reduction ${format((1 - costReducer()) * 100)}%${game.upgrades[4] >= 5 ? ' · MAXED' : ` · next ${upgradeCost(4)} stardust`}`
      ];

      ['u1', 'u2', 'u3', 'u4', 'u5'].forEach((id, i) => {
        const labelEl = document.getElementById(id);
        if (!labelEl) return;
        labelEl.textContent = labels[i];
      });

      if (sub1Unlocked()) {
        document.getElementById('sub1').textContent = `lvl ${game.subUpgrades[0]} · current boost +${format(game.subUpgrades[0])}% to Upgrade 1 · requires U1 lvl ${sub1Requirement()} · next ${sub1Cost()} stardust`;
      }
      if (sub2Unlocked()) {
        document.getElementById('sub2').textContent = `lvl ${game.subUpgrades[1]} · weighted falloff -${format(game.subUpgrades[1] * 0.01, 2)} · requires U2 lvl ${sub2Requirement()} · next ${sub2Cost()} stardust`;
      }
      if (sub3Unlocked()) {
        document.getElementById('sub3').textContent = `lvl ${game.subUpgrades[2]} · calibration bonus +${format(game.subUpgrades[2] * 2)}% · requires U3 lvl ${sub3Requirement()} · next ${sub3Cost()} stardust`;
      }

      const post25Active = game.upgrades.slice(0, 4).some((lvl) => lvl >= 25);
      document.getElementById('qolInfo').innerHTML = [
        'Auto-save every 5s',
        'Number notation: K/M/B/T',
        'Level 25+: extra upgrade-cost scaling starts',
        `Post-25 scaling: <b>${post25Active ? 'ACTIVE' : 'inactive'}</b>`,
        'Save is browser-local (this origin only)'
      ].join('<br>');

      [1, 2, 3, 4, 5].forEach((n, i) => {
        const btn = document.getElementById(`buy${n}`);
        if (!btn) return;
        if (i === 4 && (!upgrade5Unlocked() || game.upgrades[4] >= 5)) {
          btn.disabled = true;
          return;
        }
        btn.disabled = game.stardust < upgradeCost(i);
      });

      const sub1Btn = document.getElementById('buySub1');
      if (sub1Btn) {
        sub1Btn.disabled = !sub1Unlocked() || game.stardust < sub1Cost() || game.upgrades[0] < sub1Requirement();
      }
      const sub2Btn = document.getElementById('buySub2');
      if (sub2Btn) {
        sub2Btn.disabled = !sub2Unlocked() || game.stardust < sub2Cost() || game.upgrades[1] < sub2Requirement();
      }
      const sub3Btn = document.getElementById('buySub3');
      if (sub3Btn) {
        sub3Btn.disabled = !sub3Unlocked() || game.stardust < sub3Cost() || game.upgrades[2] < sub3Requirement();
      }
    }

    document.getElementById('buy1').addEventListener('click', () => buyUpgrade(0));
    document.getElementById('buy2').addEventListener('click', () => buyUpgrade(1));
    document.getElementById('buy3').addEventListener('click', () => buyUpgrade(2));
    document.getElementById('buy4').addEventListener('click', () => buyUpgrade(3));
    document.getElementById('buy5').addEventListener('click', () => buyUpgrade(4));
    document.getElementById('buySub1').addEventListener('click', buySub1);
    document.getElementById('buySub2').addEventListener('click', buySub2);
    document.getElementById('buySub3').addEventListener('click', buySub3);
    document.getElementById('rankUp').addEventListener('click', rankUp);
    document.getElementById('tierUp').addEventListener('click', tierUp);
    document.getElementById('saveNow').addEventListener('click', () => { saveGame(); render(); });
    document.getElementById('hardReset').addEventListener('click', () => {
      if (confirm('Hard reset? This will erase your save and progress.')) {
        hardResetGame();
      }
    });

    loadGame();

    setInterval(() => {
      game.stardust += generationPerSecond() / 20;
      render();
    }, 50);

    setInterval(() => {
      saveGame();
      render();
    }, 5000);

    render();
  </script>
</body>
</html>
