<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stardust</title>
  <style>
    :root {
      --bg: #121212;
      --panel: #111111;
      --line: #2f2f2f;
      --text: #f4f4f4;
      --muted: #b8b8b8;
      --accent: #ffffff;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: radial-gradient(circle at center, #3a3a3a 0%, #232323 42%, var(--bg) 100%);
      color: var(--text);
      font-family: "Press Start 2P", "VT323", "IBM Plex Mono", monospace;
      padding: 0.75rem;
    }

    .app {
      width: min(920px, 97vw);
      border: 1px solid var(--line);
      background: var(--panel);
      padding: 0.75rem;
    }

    h1 {
      margin: 0 0 0.55rem;
      font-size: 0.95rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.07em;
    }

    .grid, .upgrades {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(205px, 1fr));
      gap: 0.45rem;
      margin-bottom: 0.5rem;
    }

    .card {
      border: 1px solid var(--line);
      background: #161616;
      padding: 0.38rem;
      box-shadow: inset 0 0 10px rgba(255, 241, 118, 0.06);
    }

    #rankCard,
    #u5Card {
      border-color: #a08d2e;
    }

    #tierCard {
      border-color: #3c6cff;
    }

    .label, .upgrade-title {
      color: var(--muted);
      font-size: 0.68rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.18rem;
    }

    .value {
      font-size: 0.92rem;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
    }

    .muted {
      color: var(--muted);
      font-size: 0.72rem;
      line-height: 1.45;
      word-break: break-word;
      margin: 0.15rem 0;
    }

    .subtab {
      margin-top: 0.4rem;
      padding-top: 0.4rem;
      border-top: 1px dashed #4a4a4a;
    }

    button {
      margin-top: 0.35rem;
      width: 100%;
      border: 1px solid #4a4a4a;
      background: #121212;
      color: var(--accent);
      padding: 0.38rem;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 0.64rem;
      cursor: pointer;
    }

    button:hover:not(:disabled) {
      border-color: #fff9b0;
      color: #fff;
    }

    button:disabled {
      cursor: not-allowed;
      color: #8a8358;
      border-color: #303030;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: repeating-linear-gradient(to bottom, rgba(0, 0, 0, 0.11) 0, rgba(0, 0, 0, 0.11) 2px, transparent 2px, transparent 4px);
      opacity: 0.33;
    }
  </style>
</head>
<body>
  <main class="app">
    <h1>Stardust Incremental</h1>

    <section class="grid">
      <article class="card">
        <div class="label">Current Stardust</div>
        <div class="value" id="stardust">0</div>
      </article>

      <article class="card">
        <div class="label">Generation / second</div>
        <div class="value" id="gps">1</div>
      </article>

      <article class="card" id="rankCard">
        <div class="label">Stardust Rank</div>
        <div class="value" id="rank">0</div>
        <p class="muted" id="rankReq"></p>
        <button id="rankUp">Rank up</button>
      </article>

      <article class="card" id="tierCard" hidden>
        <div class="label">Stardust Tier</div>
        <div class="value" id="tier">0</div>
        <p class="muted" id="tierReq"></p>
        <button id="tierUp">Tier up</button>
      </article>

      <article class="card">
        <div class="label">Current Base + Current Boost</div>
        <div class="muted" id="currentStats"></div>
      </article>

      <article class="card">
        <div class="label">Save</div>
        <div class="muted" id="saveStatus">No save yet.</div>
        <button id="saveNow">Save Now</button>
        <button id="exportSave">Download Save</button>
        <button id="importSave">Import Save</button>
        <button id="downloadGame">Download Game HTML</button>
        <input id="importSaveFile" type="file" accept="application/json" hidden />
        <button id="hardReset">Hard Reset</button>
      </article>

      <article class="card">
        <div class="label">Rank Milestones</div>
        <div class="muted" id="milestones"></div>
      </article>

      <article class="card">
        <div class="label">What "Weighted" Means</div>
        <div class="muted" id="weightedHelp"></div>
      </article>
      <article class="card">
        <div class="label">Pacing Boost Details</div>
        <div class="muted" id="pacingHelp"></div>
      </article>
      <article class="card" id="starCard" hidden>
        <div class="label">Star Layer</div>
        <div class="value" id="stars">0</div>
        <p class="muted" id="starInfo"></p>
        <button id="gainStar">Gain Star</button>
        <button id="buyStar1">Buy Static Upgrade 1</button>
      </article>

      <article class="card" id="coreCard" hidden>
        <div class="label">Core Layer</div>
        <div class="value" id="cores">0</div>
        <p class="muted" id="coreInfo"></p>
        <button id="coreU1">Core Upgrade 1</button>
        <button id="coreU2">Core Upgrade 2</button>
        <button id="coreU3">Core Upgrade 3</button>
        <button id="coreU4">Core Upgrade 4</button>
        <button id="coreU5">Core Upgrade 5</button>
      </article>
    </section>

    <section class="upgrades">
      <article class="card">
        <div class="upgrade-title">Upgrade 1 · Dust Scoop</div>
        <p class="muted">+1 base generation each level.</p>
        <p class="muted" id="u1"></p>
        <button id="buy1">Buy</button>

        <div class="subtab" id="sub1Card" hidden>
          <div class="upgrade-title">Subupgrade 1 · Dust Scoop Core</div>
          <p class="muted">For Upgrade 1: +1% to its effect per sub-level.</p>
          <p class="muted" id="sub1"></p>
          <button id="buySub1">Buy Subupgrade</button>
        </div>
      </article>

      <article class="card">
        <div class="upgrade-title">Upgrade 2 · Amplifier</div>
        <p class="muted" id="desc2"></p>
        <p class="muted" id="u2"></p>
        <button id="buy2">Buy</button>

        <div class="subtab" id="sub2Card" hidden>
          <div class="upgrade-title">Subupgrade 2 · Amplifier Core</div>
          <p class="muted">Reduces weighted falloff: -0.01 each level (softcap after lvl 3 to -0.0075).</p>
          <p class="muted" id="sub2"></p>
          <button id="buySub2">Buy Subupgrade</button>
        </div>
      </article>

      <article class="card">
        <div class="upgrade-title">Upgrade 3 · Calibration</div>
        <p class="muted" id="desc3"></p>
        <p class="muted" id="u3"></p>
        <button id="buy3">Buy</button>

        <div class="subtab" id="sub3Card" hidden>
          <div class="upgrade-title">Subupgrade 3 · Dust Reactor</div>
          <p class="muted">Boosts Upgrade 1 base after Subupgrade 1 by +2.5% each level.</p>
          <p class="muted" id="sub3"></p>
          <button id="buySub3">Buy Subupgrade</button>
        </div>
      </article>

      <article class="card">
        <div class="upgrade-title">Upgrade 4 · Stabilizer</div>
        <p class="muted" id="desc4"></p>
        <p class="muted" id="u4"></p>
        <button id="buy4">Buy</button>
      </article>

      <article class="card" id="u5Card" hidden>
        <div class="upgrade-title">Upgrade 5 · Compression</div>
        <p class="muted">Reduces upgrade costs (except itself).</p>
        <p class="muted" id="u5"></p>
        <button id="buy5">Buy</button>
      </article>

    </section>
  </main>

  <script>
    const game = {
      stardust: 0,
      rank: 0,
      tier: 0,
      stars: 0,
      starUpgrades: [0],
      upgrades: [0, 0, 0, 0, 0],
      subUpgrades: [0, 0, 0],
      baseCosts: [9, 28, 72, 150, 950],
      tierUnlocked: false,
      subUnlocked: [false, false, false],
      cores: 0,
      coreAllocations: [0, 0, 0, 0, 0],
      coreInitGranted: false,
      corePacingClaimedExp: 0
    };

    const SAVE_KEY = 'stardust_incremental_save_v1';
    let lastSavedAt = null;
    let saveMessage = '';

    const defaultState = () => ({
      stardust: 0,
      rank: 0,
      tier: 0,
      stars: 0,
      starUpgrades: [0],
      upgrades: [0, 0, 0, 0, 0],
      subUpgrades: [0, 0, 0],
      tierUnlocked: false,
      subUnlocked: [false, false, false],
      cores: 0,
      coreAllocations: [0, 0, 0, 0, 0],
      coreInitGranted: false,
      corePacingClaimedExp: 0
    });

    function applyState(state) {
      const safe = defaultState();
      game.stardust = Number.isFinite(state.stardust) ? Math.max(0, state.stardust) : safe.stardust;
      game.rank = Number.isFinite(state.rank) ? Math.max(0, Math.floor(state.rank)) : safe.rank;
      game.tier = Number.isFinite(state.tier) ? Math.max(0, Math.floor(state.tier)) : safe.tier;
      game.stars = Number.isFinite(state.stars) ? Math.max(0, Math.floor(state.stars)) : safe.stars;
      game.starUpgrades = Array.isArray(state.starUpgrades) ? safe.starUpgrades.map((_, i) => {
        const v = state.starUpgrades[i];
        return Number.isFinite(v) ? Math.max(0, Math.floor(v)) : 0;
      }) : safe.starUpgrades;
      game.upgrades = Array.isArray(state.upgrades) ? safe.upgrades.map((_, i) => {
        const v = state.upgrades[i];
        return Number.isFinite(v) ? Math.max(0, Math.floor(v)) : 0;
      }) : safe.upgrades;
      game.subUpgrades = Array.isArray(state.subUpgrades) ? safe.subUpgrades.map((_, i) => {
        const v = state.subUpgrades[i];
        return Number.isFinite(v) ? Math.max(0, Math.floor(v)) : 0;
      }) : safe.subUpgrades;
      game.cores = Number.isFinite(state.cores) ? Math.max(0, Math.floor(state.cores)) : safe.cores;
      game.coreAllocations = Array.isArray(state.coreAllocations) ? safe.coreAllocations.map((_, i) => {
        const v = state.coreAllocations[i];
        return Number.isFinite(v) ? Math.max(0, Math.floor(v)) : 0;
      }) : safe.coreAllocations;
      game.coreInitGranted = state.coreInitGranted === true;
      game.corePacingClaimedExp = Number.isFinite(state.corePacingClaimedExp) ? Math.max(0, Math.floor(state.corePacingClaimedExp)) : safe.corePacingClaimedExp;
      game.tierUnlocked = state.tierUnlocked === true || game.tier >= 1 || game.rank >= 5;
      game.subUnlocked = Array.isArray(state.subUnlocked) ? safe.subUnlocked.map((_, i) => {
        const v = state.subUnlocked[i];
        return v === true;
      }) : safe.subUnlocked;

      // Backward compatibility for older saves without explicit sub unlock flags.
      game.subUnlocked[0] = game.subUnlocked[0] || game.rank >= 5 || game.subUpgrades[0] > 0;
      game.subUnlocked[1] = game.subUnlocked[1] || game.tier >= 1 || game.subUpgrades[1] > 0;
      game.subUnlocked[2] = game.subUnlocked[2] || game.rank >= 7 || game.subUpgrades[2] > 0;
      game.coreInitGranted = game.coreInitGranted || game.rank >= 8 || game.cores > 0;
      const usedCores = game.coreAllocations.reduce((a, b) => a + b, 0);
      if (usedCores > game.cores) game.cores = usedCores;
      game.corePacingClaimedExp = Math.max(0, game.corePacingClaimedExp);
    }

    function buildSavePayload() {
      return {
        stardust: game.stardust,
        rank: game.rank,
        tier: game.tier,
        stars: game.stars,
        starUpgrades: game.starUpgrades,
        upgrades: game.upgrades,
        subUpgrades: game.subUpgrades,
        tierUnlocked: game.tierUnlocked,
        subUnlocked: game.subUnlocked,
        cores: game.cores,
        coreAllocations: game.coreAllocations,
        coreInitGranted: game.coreInitGranted,
        corePacingClaimedExp: game.corePacingClaimedExp,
        savedAt: Date.now()
      };
    }

    function saveGame() {
      const payload = buildSavePayload();
      localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
      lastSavedAt = payload.savedAt;
    }

    function loadGame() {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return false;
      try {
        const parsed = JSON.parse(raw);
        applyState(parsed);
        lastSavedAt = Number.isFinite(parsed.savedAt) ? parsed.savedAt : null;
        return true;
      } catch {
        return false;
      }
    }

    function hardResetGame() {
      localStorage.removeItem(SAVE_KEY);
      applyState(defaultState());
      lastSavedAt = null;
      saveMessage = '';
      render();
    }

    function downloadSaveFile() {
      const payload = buildSavePayload();
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `stardust-save-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      saveMessage = 'Save file downloaded.';
    }

    function importSaveFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const parsed = JSON.parse(String(reader.result || '{}'));
          applyState(parsed);
          saveGame();
          saveMessage = 'Save file imported.';
          render();
        } catch {
          saveMessage = 'Import failed: invalid save file.';
          render();
        }
      };
      reader.readAsText(file);
    }

    function downloadGameHtml() {
      const html = `<!DOCTYPE html>
${document.documentElement.outerHTML}`;
      const blob = new Blob([html], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'stardust-incremental.html';
      a.click();
      URL.revokeObjectURL(url);
      saveMessage = 'HTML file downloaded.';
    }

    const format = (n, digits = 2) => {
      if (!Number.isFinite(n)) return '∞';
      const sign = n < 0 ? '-' : '';
      const value = Math.abs(n);
      if (value < 1000) {
        return sign + value.toLocaleString(undefined, { maximumFractionDigits: digits });
      }
      const suffixes = ['', 'K', 'M', 'B', 'T', 'Qa', 'Qi', 'Sx', 'Sp'];
      let tier = 0;
      let scaled = value;
      while (scaled >= 1000 && tier < suffixes.length - 1) {
        scaled /= 1000;
        tier += 1;
      }
      return `${sign}${scaled.toFixed(scaled >= 100 ? 0 : scaled >= 10 ? 1 : 2)}${suffixes[tier]}`;
    };

    const rankUnlocked = () => game.upgrades[3] >= 5;
    const tierUnlocked = () => game.tierUnlocked || game.rank >= 5;
    const tierRequirementRank = () => 5 + game.tier * 4;
    const upgrade5Unlocked = () => game.rank >= 1;
    const sub1Unlocked = () => game.subUnlocked[0] || game.rank >= 5;
    const sub2Unlocked = () => game.subUnlocked[1] || game.tier >= 1;
    const sub3Unlocked = () => game.subUnlocked[2] || game.rank >= 7;
    const autoU1Unlocked = () => game.tier >= 1;
    const autoU2Unlocked = () => game.rank >= 8;
    const starLayerUnlocked = () => game.rank >= 13 || game.stars > 0 || game.starUpgrades[0] > 0;
    const starRequirement = () => 1e12;
    const coreUnlocked = () => game.rank >= 8 || game.coreInitGranted || game.cores > 0;
    const usedCores = () => game.coreAllocations.reduce((a, b) => a + b, 0);
    const freeCores = () => Math.max(0, game.cores - usedCores());
    const coreBoostMultiplier = (index) => 1 + game.coreAllocations[index] * 0.25;
    const allocateCore = (index) => {
      if (!coreUnlocked()) return;
      if (freeCores() <= 0) return;
      game.coreAllocations[index] += 1;
      render();
    };
    const upgrade5Cap = () => (game.tier >= 1 ? 100 : 5) + game.starUpgrades[0] * 2;

    const rankRequirementU4Level = () => {
      if (game.rank <= 4) {
        return 5 + game.rank * 2;
      }
      return 13 + (game.rank - 4) * 3;
    };

    const rankPerRankBoost = () => 1.2;

    const rankGenerationMultiplier = () => {
      if (game.rank === 0) return 1;
      return 2 * Math.pow(rankPerRankBoost(), Math.max(0, game.rank - 1));
    };

    const stabilizerRankBoost = () => 1;

    const stabilizerBasePercent = () => {
      const lvl = game.upgrades[3];
      const preSoftcap = Math.min(lvl, 9) * 35;
      const postLevels = Math.max(0, lvl - 9);
      const postSoftcap = postLevels * 5;
      return (preSoftcap + postSoftcap) * coreBoostMultiplier(3);
    };

    const stabilizerMultiplier = () => 1 + stabilizerBasePercent() / 100;

    const tierU3ToU1Boost = () => 1;

    const sub1Multiplier = () => 1 + game.subUpgrades[0] * 0.01;
    const sub3U1Multiplier = () => 1 + game.subUpgrades[2] * 0.025;

    const sub2FalloffReduction = () => {
      const lvl = game.subUpgrades[1];
      const early = Math.min(3, lvl) * 0.01;
      const late = Math.max(0, lvl - 3) * 0.0075;
      return early + late;
    };

    const weightFalloff = () => {
      const base = game.rank >= 3 ? 0.07 : 0.12;
      const sub2Reduce = sub2FalloffReduction();
      return base - sub2Reduce;
    };

    const pacingMaxMultiplier = () => {
      if (game.rank >= 8) return null;
      if (game.rank >= 4) return 10;
      if (game.rank >= 2) return 3;
      return 1.5;
    };

    const pacingProgressionScore = () => {
      const sub1Part = sub1Unlocked() ? game.subUpgrades[0] : 0;
      return game.upgrades[0] + sub1Part + game.upgrades[1] + game.upgrades[2] + game.upgrades[3];
    };

    const pacingBreakdown = () => {
      const progression = pacingProgressionScore();
      const capMultiplier = pacingMaxMultiplier();
      const capAdd = capMultiplier === null ? null : capMultiplier - 1;
      const maybeCap = (value) => (capAdd === null ? value : Math.min(capAdd, value));

      const progressPart = maybeCap(progression * 0.01);

      const rankLinearBaseRaw = game.rank * 0.04;
      const rankLinearBase = maybeCap(rankLinearBaseRaw);
      const rankMultiplier = game.rank >= 6 ? Math.pow(1.06, game.rank) : 1;
      const rankPart = game.rank >= 6 ? Math.max(0, (1 + rankLinearBase) * rankMultiplier - 1) : rankLinearBase;

      const tierLinearRaw = game.tier * 0.08;
      const tierLinearBase = maybeCap(tierLinearRaw);
      const tierMultiplier = game.rank >= 9 ? Math.pow(1.08, game.tier) : 1;
      const tierPart = game.rank >= 9 ? Math.max(0, (1 + tierLinearBase) * tierMultiplier - 1) : tierLinearBase;

      const corePacingPart = game.tier >= 2 ? usedCores() * 0.22 : 0;
      const totalAdd = progressPart + rankPart + tierPart + corePacingPart;
      const total = 1 + (capAdd === null ? totalAdd : Math.min(capAdd, totalAdd));
      return { total, progressPart, rankPart, tierPart, corePacingPart, capMultiplier };
    };

    const pacingBoost = () => pacingBreakdown().total;

    function grantCoresFromPacingBoost() {
      if (!coreUnlocked()) return;
      const pace = pacingBoost();
      if (!Number.isFinite(pace) || pace < 10) return;
      const maxExp = Math.min(300, Math.floor(Math.log10(pace)));
      while (game.corePacingClaimedExp < maxExp) {
        game.corePacingClaimedExp += 1;
        game.cores += 1;
      }
    }

    const costReducer = () => {
      if (!upgrade5Unlocked()) return 1;
      const level = game.upgrades[4];
      const primaryLevels = Math.min(5, level);
      const primaryReduce = Math.min(0.45, 1 - Math.pow(0.96, primaryLevels));
      let extraReduce = 0;
      const extraLevels = Math.max(0, level - 5);
      for (let i = 0; i < extraLevels; i += 1) {
        // Post-5 is stronger so the levels matter, then softcaps again after level 50.
        const u5Level = i + 6;
        if (u5Level <= 50) {
          extraReduce += 0.016 / (1 + i * 0.32);
        } else {
          const lateIndex = u5Level - 50;
          extraReduce += 0.0048 / (1 + lateIndex * 0.75);
        }
      }
      const coreU5Factor = 1 + (coreBoostMultiplier(4) - 1) * 0.7;
      const totalReduce = Math.min(0.85, (primaryReduce + extraReduce) * coreU5Factor);
      return 1 - totalReduce;
    };

    const postThresholdForUpgrade = (index) => {
      if (index === 2) return 6;
      if (index === 3) return 15;
      return 25;
    };

    const postScalingMultiplier = (index, level) => {
      const threshold = postThresholdForUpgrade(index);
      if (level < threshold) return 1;
      const extra = level - threshold + 1;
      if (index === 3) {
        return Math.pow(1.2, extra) * (1 + extra * 0.12 + extra * extra * 0.02);
      }
      return Math.pow(1.18, extra) * (1 + extra * 0.1 + extra * extra * 0.015);
    };

    const upgradeCost = (index) => {
      const growth = [1.34, 1.75, 1.95, 2.08, 2.62][index];
      const level = game.upgrades[index];
      const base = game.baseCosts[index] * Math.pow(growth, level);
      const scaled = base * postScalingMultiplier(index, level);
      if (index === 4) return Math.floor(scaled);
      return Math.floor(scaled * costReducer());
    };

    const sub1Requirement = () => (game.subUpgrades[0] + 1) * 5;
    const sub2Requirement = () => (game.subUpgrades[1] + 1) * 5;
    const sub2Cost = () => Math.floor(180 * Math.pow(1.62, game.subUpgrades[1]));
    const sub3Requirement = () => (game.subUpgrades[2] + 1) * 6;

    const upgrade2BasePercentRaw = () => {
      const base = 20 * coreBoostMultiplier(1);
      const calibrationBoost = 1 + game.upgrades[2] * 0.08 * coreBoostMultiplier(2);
      const stabilizerBoost = stabilizerMultiplier() * stabilizerRankBoost();
      return base * calibrationBoost * stabilizerBoost;
    };

    const dampenPercent = (rawPercent) => {
      if (rawPercent <= 60) return rawPercent;
      if (rawPercent <= 180) return 60 + Math.pow(rawPercent - 60, 0.5) * 4.2;
      return 60 + Math.pow(120, 0.5) * 4.2 + Math.log10(rawPercent - 179) * 5.2;
    };

    const weightedU2Levels = (levels) => {
      let total = 0;
      for (let i = 0; i < levels; i += 1) {
        const denom = 1 + i * weightFalloff();
        const safeDenom = Math.abs(denom) < 0.05 ? (denom < 0 ? -0.05 : 0.05) : denom;
        const basePart = 1 / safeDenom;
        const softcap30 = i >= 30 ? 1 / (1 + (i - 29) * 0.18) : 1;
        const softcap20 = i >= 20 ? 1 / (1 + (i - 19) * 0.25) : 1;
        total += basePart * softcap30 * softcap20;
      }
      return total;
    };

    const weightedU2LevelsNoSoftcap = (levels) => {
      let total = 0;
      for (let i = 0; i < levels; i += 1) {
        const denom = 1 + i * weightFalloff();
        const safeDenom = Math.abs(denom) < 0.05 ? (denom < 0 ? -0.05 : 0.05) : denom;
        total += 1 / safeDenom;
      }
      return total;
    };

    const currentBaseGeneration = () => {
      const u1Base = (1 + game.upgrades[0]) * sub1Multiplier() * sub3U1Multiplier() * coreBoostMultiplier(0);
      return u1Base * rankGenerationMultiplier() * tierU3ToU1Boost() * pacingBoost();
    };

    const currentUpgrade2Multiplier = () => {
      const u2PercentEach = dampenPercent(upgrade2BasePercentRaw());
      const u2LevelsWeighted = weightedU2Levels(game.upgrades[1]);
      return Math.pow(1 + u2PercentEach / 100, u2LevelsWeighted);
    };

    const generationPerSecond = () => currentBaseGeneration() * currentUpgrade2Multiplier();

    const applyStardustGainSoftcap = (gainPerSecond) => {
      if (gainPerSecond <= 1e6) return gainPerSecond;
      const after1M = 1e6 + Math.pow(gainPerSecond - 1e6, 0.6);
      if (after1M <= 1e12) return after1M;
      return 1e12 + Math.pow(after1M - 1e12, 0.45);
    };

    function buyUpgrade(index, shouldRender = true) {
      const cardLocked = index === 4 && !upgrade5Unlocked();
      if (cardLocked) return false;
      if (index === 4 && game.upgrades[4] >= upgrade5Cap()) return false;
      const cost = upgradeCost(index);
      if (game.stardust < cost) return false;
      game.stardust -= cost;
      game.upgrades[index] += 1;
      if (shouldRender) render();
      return true;
    }

    function buySub1(shouldRender = true) {
      if (!sub1Unlocked()) return false;
      if (game.upgrades[0] < sub1Requirement()) return false;
      game.subUpgrades[0] += 1;
      if (shouldRender) render();
      return true;
    }

    function buySub2(shouldRender = true) {
      if (!sub2Unlocked()) return false;
      if (game.upgrades[1] < sub2Requirement()) return false;
      const cost = sub2Cost();
      if (game.stardust < cost) return false;
      game.stardust -= cost;
      game.subUpgrades[1] += 1;
      if (shouldRender) render();
      return true;
    }

    function buySub3(shouldRender = true) {
      if (!sub3Unlocked()) return false;
      if (game.upgrades[2] < sub3Requirement()) return false;
      game.subUpgrades[2] += 1;
      if (shouldRender) render();
      return true;
    }

    function autoBuySubupgradesByRequirement() {
      let loops = 0;
      while (loops < 200 && buySub1(false)) loops += 1;
      loops = 0;
      while (loops < 200 && buySub2(false)) loops += 1;
      loops = 0;
      while (loops < 200 && buySub3(false)) loops += 1;
    }

    function runAutoBuyers() {
      if (autoU1Unlocked()) {
        game.upgrades[0] += 1;
        if (game.upgrades[0] >= sub1Requirement()) {
          game.subUpgrades[0] += 1;
        }
      }

      if (autoU2Unlocked()) {
        let loops = 0;
        while (loops < 200 && buyUpgrade(1, false)) loops += 1;
        loops = 0;
        while (loops < 200 && buySub2(false)) loops += 1;
      }
    }

    function gainStar() {
      if (!starLayerUnlocked()) return;
      if (game.stars >= 1) return;
      if (game.stardust < starRequirement()) return;
      game.stardust -= starRequirement();
      game.stars = 1;
      if (coreUnlocked()) game.cores += 1;
      render();
    }

    function buyStar1() {
      if (!starLayerUnlocked()) return;
      if (game.starUpgrades[0] >= 1) return;
      if (game.stars < 1) return;
      game.stars -= 1;
      game.starUpgrades[0] = 1;
      render();
    }

    function rankUp() {
      if (!rankUnlocked()) return;
      if (game.upgrades[3] < rankRequirementU4Level()) return;
      game.rank += 1;
      game.stardust = 0;
      game.upgrades = [0, 0, 0, 0, 0];
      render();
    }

    function tierUp() {
      if (!tierUnlocked()) return;
      if (game.rank < tierRequirementRank()) return;
      game.tier += 1;
      game.rank = 0;
      game.stardust = 0;
      game.upgrades = [0, 0, 0, 0, 0];
      render();
    }

    function render() {
      if (game.rank >= 5 && !game.tierUnlocked) game.tierUnlocked = true;
      if (game.rank >= 8 && !game.coreInitGranted) {
        game.coreInitGranted = true;
        game.cores += 1;
      }
      if (game.rank >= 5) game.subUnlocked[0] = true;
      if (game.tier >= 1) game.subUnlocked[1] = true;
      if (game.rank >= 7) game.subUnlocked[2] = true;

      const gpsRaw = generationPerSecond();
      const gps = applyStardustGainSoftcap(gpsRaw);
      const baseGen = currentBaseGeneration();
      const raw = upgrade2BasePercentRaw();
      const eff = dampenPercent(raw);
      const weighted = weightedU2Levels(game.upgrades[1]);
      const weightedNoSoftcap = weightedU2LevelsNoSoftcap(game.upgrades[1]);
      const weightedSoftcapFactor = weightedNoSoftcap > 0 ? weighted / weightedNoSoftcap : 1;
      const weightedSoftcapLoss = Math.max(0, 1 - weightedSoftcapFactor);
      const u2CurrentMultiplier = currentUpgrade2Multiplier();
      const stardustSoftcapFactor = gpsRaw > 0 ? gps / gpsRaw : 1;
      const stardustSoftcapLoss = Math.max(0, 1 - stardustSoftcapFactor);

      document.getElementById('stardust').textContent = format(game.stardust);
      document.getElementById('gps').textContent = format(gps, 3);
      document.getElementById('rank').textContent = game.rank;
      document.getElementById('tier').textContent = game.tier;
      document.getElementById('stars').textContent = game.stars;

      const rankButton = document.getElementById('rankUp');
      if (!rankUnlocked()) {
        document.getElementById('rankReq').textContent = 'Unlock at Upgrade 4 level 5.';
        rankButton.disabled = true;
      } else {
        document.getElementById('rankReq').textContent = `Requirement: Upgrade 4 level ${rankRequirementU4Level()}.`;
        rankButton.disabled = game.upgrades[3] < rankRequirementU4Level();
      }

      const tierButton = document.getElementById('tierUp');
      document.getElementById('tierCard').hidden = !tierUnlocked();
      if (!tierUnlocked()) {
        document.getElementById('tierReq').textContent = 'Locked: unlocks at Rank 5 (permanent).';
        tierButton.disabled = true;
      } else {
        document.getElementById('tierReq').textContent = `Requirement: Rank ${tierRequirementRank()} (+4 each tier). Tier resets rank, stardust, and upgrades.`;
        tierButton.disabled = game.rank < tierRequirementRank();
      }

      document.getElementById('u5Card').hidden = !upgrade5Unlocked();
      document.getElementById('sub1Card').hidden = !sub1Unlocked();
      document.getElementById('sub2Card').hidden = !sub2Unlocked();
      document.getElementById('sub3Card').hidden = !sub3Unlocked();
      document.getElementById('starCard').hidden = !starLayerUnlocked();
      document.getElementById('coreCard').hidden = !coreUnlocked();
      if (coreUnlocked()) {
        document.getElementById('cores').textContent = format(game.cores, 0);
        document.getElementById('coreInfo').innerHTML = [
          `Free cores: <b>${format(freeCores(), 0)}</b> · Used: <b>${format(usedCores(), 0)}</b>`,
          'Each core boosts one chosen upgrade by +25% (stacking).',
          `Free core per pacing milestone: <b>x10^n</b> (claimed up to n=${format(game.corePacingClaimedExp, 0)})`,
          `U1 x${format(coreBoostMultiplier(0), 2)} · U2 x${format(coreBoostMultiplier(1), 2)} · U3 x${format(coreBoostMultiplier(2), 2)} · U4 x${format(coreBoostMultiplier(3), 2)} · U5 x${format(coreBoostMultiplier(4), 2)}`
        ].join('<br>');
      }

      if (starLayerUnlocked()) {
        const starInfo = [
          `Requirement: ${format(starRequirement())} stardust for 1 star (max 1).`,
          `Static Upgrade 1: ${game.starUpgrades[0] >= 1 ? 'BOUGHT' : 'adds +2 cap to Upgrade 5'}`
        ];
        document.getElementById('starInfo').innerHTML = starInfo.join('<br>');
        document.getElementById('gainStar').disabled = game.stars >= 1 || game.stardust < starRequirement();
        document.getElementById('buyStar1').disabled = game.starUpgrades[0] >= 1 || game.stars < 1;
      }

      const u1RawBase = 1 + game.upgrades[0];
      const u1SubBoost = sub1Multiplier();
      const u1Sub3Boost = sub3U1Multiplier();
      const rankBoost = rankGenerationMultiplier();
      const tierBoost = tierU3ToU1Boost();
      const paceBoost = pacingBoost();
      const stabilizerBase = stabilizerMultiplier();
      
      document.getElementById('currentStats').innerHTML = [
        '<b>Bases</b>',
        `U1 raw base: <b>${format(u1RawBase, 2)}/s</b>`,
        `U2 raw base effect: <b>${format(raw, 2)}%</b>`,
        '<b>Boosts</b>',
        `Subupgrade 1 (U1): <b>x${format(u1SubBoost, 3)}</b>`,
        `Subupgrade 3 (U1 post-Sub1): <b>x${format(u1Sub3Boost, 3)}</b>`,
        `Rank generation: <b>x${format(rankBoost, 3)}</b>`,
        `Rank per-rank boost: <b>x${format(rankPerRankBoost(), 2)}</b>`,
        `Rank 3 bonus (weighted): <b>falloff ${format(weightFalloff(), 2)}</b>`,
        `Tier synergy: <b>x${format(tierBoost, 3)}</b>`,
        `Subupgrade 2 falloff cut: <b>-${format(sub2FalloffReduction(), 3)}</b>`,
        `Upgrade 5 cap: <b>${upgrade5Cap()}</b>`,
        `Core boosts: <b>U1 x${format(coreBoostMultiplier(0), 2)} · U2 x${format(coreBoostMultiplier(1), 2)} · U3 x${format(coreBoostMultiplier(2), 2)} · U4 x${format(coreBoostMultiplier(3), 2)} · U5 x${format(coreBoostMultiplier(4), 2)}</b>`,
        `Pacing boost: <b>x${format(paceBoost, 3)}</b>`,
        `U4 stabilizer base: <b>x${format(stabilizerBase, 3)}</b>`,
        `U2 total multiplier: <b>x${format(u2CurrentMultiplier, 3)}</b>`,
        `Raw GPS: <b>${format(gpsRaw, 3)}/s</b>`,
        `Softcapped GPS: <b>${format(gps, 3)}/s</b>`,
        `Stardust softcap effect: <b>x${format(stardustSoftcapFactor, 4)}</b> (${format(stardustSoftcapLoss * 100, 2)}% reduced)`,
        `Weighted softcap effect: <b>x${format(weightedSoftcapFactor, 4)}</b> (${format(weightedSoftcapLoss * 100, 2)}% reduced)`,
        `Stardust gain softcaps: <b>1M</b> then <b>1T</b>`
      ].join('<br>');

      const saveLabel = document.getElementById('saveStatus');
      const baseSaveText = lastSavedAt
        ? `Last save: ${new Date(lastSavedAt).toLocaleTimeString()}`
        : 'No save yet.';
      saveLabel.textContent = saveMessage ? `${baseSaveText} · ${saveMessage}` : baseSaveText;

      const rankMilestones = [
        '<b>Rank Milestones</b>',
        `${game.rank >= 1 ? '✓' : '·'} Rank 1: Unlock Upgrade 5 + generation x2`,
        `${game.rank >= 2 ? '✓' : '·'} Rank 2: Pacing cap becomes x3`,
        `${game.rank >= 3 ? '✓' : '·'} Rank 3: Better weighted scaling`,
        `${game.rank >= 4 ? '✓' : '·'} Rank 4: Pacing cap becomes x10`,
        `${game.rank >= 5 ? '✓' : '·'} Rank 5: Unlock Tier system + Subupgrade 1 (permanent)`,
        `${game.rank >= 6 ? '✓' : '·'} Rank 6: Rank pacing becomes multiplicative`,
        `${game.rank >= 7 ? '✓' : '·'} Rank 7: Unlock Subupgrade 3`,
        `${game.rank >= 8 ? '✓' : '·'} Rank 8: Remove pacing cap + unlock Cores`,
        `${game.rank >= 9 ? '✓' : '·'} Rank 9: Tier pacing becomes multiplicative`,
        `${game.rank >= 13 ? '✓' : '·'} Rank 13: Unlock Star Layer`
      ];
      const tierMilestones = [
        '<b>Tier Milestones</b>',
        `${game.tier >= 1 ? '✓' : '·'} Tier 1: Upgrade 1 and Subupgrade 1 are free and auto-bought + Upgrade 5 cap to 100`,
        `${game.tier >= 2 ? '✓' : '·'} Tier 2: Used cores greatly boost pacing`
      ];
      document.getElementById('milestones').innerHTML = [...rankMilestones, '', ...tierMilestones].join('<br>');

      const weightedNow = weightedU2Levels(game.upgrades[1]);
      const nextWeighted = weightedU2Levels(game.upgrades[1] + 1);
      document.getElementById('weightedHelp').innerHTML = [
        'Weighted = each Upgrade 2 level gives a little less than the one before.',
        `Current: <b>${game.upgrades[1]} levels => ${format(weightedNow, 2)} weighted</b>`,
        `No-softcap weighted: <b>${format(weightedNoSoftcap, 2)}</b>`,
        `Weighted softcap effect: <b>x${format(weightedSoftcapFactor, 4)}</b> (${format(weightedSoftcapLoss * 100, 2)}% reduced)`,
        `Next level adds: <b>+${format(nextWeighted - weightedNow, 3)} weighted</b>`,
        `Weight falloff: <b>${weightFalloff()}</b> (${game.rank >= 3 ? 'improved by Rank 3 + Sub2' : 'base'})`,
        'Upgrade 2 softcaps: weighted contribution is reduced after <b>level 20</b> and again after <b>level 30</b>.',
        'If falloff ever became negative, later levels would become stronger instead of weaker.',
        'Negative falloff is allowed: after enough reduction, later levels can contribute more weighted value instead of less.',
      ].join('<br>');

      const { progressPart: pacingFromProgress, rankPart: pacingFromRank, tierPart: pacingFromTier, corePacingPart, capMultiplier } = pacingBreakdown();
      document.getElementById('pacingHelp').innerHTML = [
        `Current pacing boost: <b>x${format(pacingBoost(), 3)}</b>`,
        `From upgrades: <b>+${format(pacingFromProgress * 100, 2)}%</b>`,
        `From rank: <b>+${format(pacingFromRank * 100, 2)}%</b>`,
        `From tier: <b>+${format(pacingFromTier * 100, 2)}%</b>`,
        `From used cores: <b>+${format(corePacingPart * 100, 2)}%</b>${game.tier >= 2 ? ' (Tier 2 active)' : ' (locked until Tier 2)'}`,
        `${capMultiplier === null ? 'Cap: <b>none</b> (Rank 8 removed limit)' : `Cap: x${format(capMultiplier, 2)} total pacing boost (${game.rank >= 4 ? 'Rank 4: x10 cap' : game.rank >= 2 ? 'Rank 2: x3 cap' : 'Base: x1.5 cap'})`}`,
        `Rank pacing mode: <b>${game.rank >= 6 ? 'multiplicative (Rank 6)' : 'additive'}</b>`,
        `Tier pacing mode: <b>${game.rank >= 9 ? 'multiplicative (Rank 9)' : 'additive'}</b>`
      ].join('<br>');

      const u3ScaleStart = postThresholdForUpgrade(2);
      document.getElementById('desc2').textContent = `Upgrade 2 uses weighted stacking with harsher softcaps at lvl 20 and lvl 30. Current effective per-level: +${format(eff, 2)}%. Weighted softcap now: x${format(weightedSoftcapFactor, 3)}.`;
      document.getElementById('desc3').textContent = `Upgrade 3 adds +8% to Upgrade 2 base per level (extra cost scaling starts at lvl ${u3ScaleStart}).`;
      document.getElementById('desc4').textContent = `Upgrade 4 additive boost is dynamic: +35%/lvl until 9, then +5%/lvl after softcap.`;

      const u1CurrentBase = u1RawBase * sub1Multiplier();
      const labels = [
        autoU1Unlocked()
          ? `lvl ${game.upgrades[0]} · raw base ${format(u1RawBase, 2)}/s · current ${format(u1CurrentBase, 2)}/s · Tier 1 free autobuy active${game.upgrades[0] >= 25 ? ' · post-25 scaling' : ''}`
          : `lvl ${game.upgrades[0]} · raw base ${format(u1RawBase, 2)}/s · current ${format(u1CurrentBase, 2)}/s · next ${format(upgradeCost(0))} stardust${game.upgrades[0] >= 25 ? ' · post-25 scaling' : ''}`,
        `lvl ${game.upgrades[1]} · raw ${format(raw)}% · current ${format(eff)}% · boost x${format(u2CurrentMultiplier, 3)} · next ${format(upgradeCost(1))} stardust${game.upgrades[1] >= 20 ? ' · weighted softcap active' : ''}${game.upgrades[1] >= 25 ? ' · post-25 scaling' : ''}`,
        `lvl ${game.upgrades[2]} · raw +${format(game.upgrades[2] * 8)}% to u2 · current x${format(1 + game.upgrades[2] * 0.08, 3)} · next ${format(upgradeCost(2))} stardust${game.upgrades[2] >= 6 ? ' · post-6 scaling' : ''}`,
        `lvl ${game.upgrades[3]} · current +${format(stabilizerBasePercent(), 1)}% to u2 (softcap after 9: +5%/lvl) · current x${format(stabilizerMultiplier() * stabilizerRankBoost(), 3)} · next ${format(upgradeCost(3))} stardust${game.upgrades[3] >= 15 ? ' · post-15 scaling' : ''}`,
        `lvl ${game.upgrades[4]} / ${upgrade5Cap()} · current cost reduction ${format((1 - costReducer()) * 100)}%${game.upgrades[4] >= upgrade5Cap() ? ' · MAXED' : ` · next ${format(upgradeCost(4))} stardust`} · post-5 gains stronger; second softcap after lvl 50`
      ];

      ['u1', 'u2', 'u3', 'u4', 'u5'].forEach((id, i) => {
        const labelEl = document.getElementById(id);
        if (!labelEl) return;
        labelEl.textContent = labels[i];
      });

      if (sub1Unlocked()) {
        document.getElementById('sub1').textContent = autoU1Unlocked()
          ? `lvl ${game.subUpgrades[0]} · Tier 1 autobuy active (free) · buys only at U1 lvl ${sub1Requirement()}`
          : `lvl ${game.subUpgrades[0]} · current boost +${format(game.subUpgrades[0])}% to Upgrade 1 · auto-buys at U1 lvl ${sub1Requirement()}`;
      }
      if (sub2Unlocked()) {
        document.getElementById('sub2').textContent = autoU2Unlocked()
          ? `lvl ${game.subUpgrades[1]} · Rank 8 autobuy active`
          : `lvl ${game.subUpgrades[1]} · weighted falloff -${format(sub2FalloffReduction(), 3)} (softcap after 3) · auto-buys at U2 lvl ${sub2Requirement()} if you have ${format(sub2Cost())} stardust`;
      }
      if (sub3Unlocked()) {
        document.getElementById('sub3').textContent = `lvl ${game.subUpgrades[2]} · Upgrade 1 post-Sub1 boost +${format(game.subUpgrades[2] * 2.5)}% · auto-buys at U3 lvl ${sub3Requirement()}`;
      }


      [1, 2, 3, 4, 5].forEach((n, i) => {
        const btn = document.getElementById(`buy${n}`);
        if (!btn) return;
        if (i === 4 && (!upgrade5Unlocked() || game.upgrades[4] >= upgrade5Cap())) {
          btn.disabled = true;
          return;
        }
        btn.disabled = (i === 0 && autoU1Unlocked()) || (i === 1 && autoU2Unlocked()) || game.stardust < upgradeCost(i);
      });

      const sub1Btn = document.getElementById('buySub1');
      if (sub1Btn) {
        sub1Btn.disabled = autoU1Unlocked() || !sub1Unlocked() || game.upgrades[0] < sub1Requirement();
      }
      const sub2Btn = document.getElementById('buySub2');
      if (sub2Btn) {
        sub2Btn.disabled = autoU2Unlocked() || !sub2Unlocked() || game.upgrades[1] < sub2Requirement() || game.stardust < sub2Cost();
      }
      const sub3Btn = document.getElementById('buySub3');
      if (sub3Btn) {
        sub3Btn.disabled = !sub3Unlocked() || game.upgrades[2] < sub3Requirement();
      }

      ['coreU1', 'coreU2', 'coreU3', 'coreU4', 'coreU5'].forEach((id, i) => {
        const btn = document.getElementById(id);
        if (!btn) return;
        btn.disabled = !coreUnlocked() || freeCores() <= 0;
        btn.textContent = `Core Upgrade ${i + 1} (${format(game.coreAllocations[i], 0)})`;
      });

    }

    document.getElementById('buy1').addEventListener('click', () => buyUpgrade(0));
    document.getElementById('buy2').addEventListener('click', () => buyUpgrade(1));
    document.getElementById('buy3').addEventListener('click', () => buyUpgrade(2));
    document.getElementById('buy4').addEventListener('click', () => buyUpgrade(3));
    document.getElementById('buy5').addEventListener('click', () => buyUpgrade(4));
    document.getElementById('buySub1').addEventListener('click', buySub1);
    document.getElementById('buySub2').addEventListener('click', buySub2);
    document.getElementById('buySub3').addEventListener('click', buySub3);
    document.getElementById('rankUp').addEventListener('click', rankUp);
    document.getElementById('tierUp').addEventListener('click', tierUp);
    document.getElementById('saveNow').addEventListener('click', () => { saveGame(); render(); });
    document.getElementById('exportSave').addEventListener('click', () => { downloadSaveFile(); render(); });
    document.getElementById('importSave').addEventListener('click', () => {
      document.getElementById('importSaveFile').click();
    });
    document.getElementById('importSaveFile').addEventListener('change', (e) => {
      const [file] = e.target.files || [];
      importSaveFile(file);
      e.target.value = '';
    });
    document.getElementById('downloadGame').addEventListener('click', () => { downloadGameHtml(); render(); });
    document.getElementById('gainStar').addEventListener('click', gainStar);
    document.getElementById('buyStar1').addEventListener('click', buyStar1);
    document.getElementById('coreU1').addEventListener('click', () => allocateCore(0));
    document.getElementById('coreU2').addEventListener('click', () => allocateCore(1));
    document.getElementById('coreU3').addEventListener('click', () => allocateCore(2));
    document.getElementById('coreU4').addEventListener('click', () => allocateCore(3));
    document.getElementById('coreU5').addEventListener('click', () => allocateCore(4));
    document.getElementById('hardReset').addEventListener('click', () => {
      if (confirm('Hard reset? This will erase your save and progress.')) {
        hardResetGame();
      }
    });

    loadGame();

    setInterval(() => {
      game.stardust += applyStardustGainSoftcap(generationPerSecond()) / 20;
      runAutoBuyers();
      autoBuySubupgradesByRequirement();
      grantCoresFromPacingBoost();
      render();
    }, 50);

    setInterval(() => {
      saveGame();
      render();
    }, 5000);

    render();
  </script>
</body>
</html>
